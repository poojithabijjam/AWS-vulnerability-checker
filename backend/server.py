import boto3
from abc import ABC, abstractmethod
from dotenv import dotenv_values
from flask import Flask, jsonify
from flask_cors import CORS

app = Flask(__name__)
cors = CORS(app)
app.config['CORS_HEADERS'], app.secret_key, config = 'Content-Type', 'securitycheck', dotenv_values(".env")


class Base_Solution_Class(ABC):
    @abstractmethod
    def __init__(self):
        raise NotImplementedError(
            "__init__() not defined")

    @abstractmethod
    def run(self):
        raise NotImplementedError(
            "run() not defined")


class EC2_Ports_Exposed(Base_Solution_Class):
    def __init__(self, sess):
        self.sess = sess

    def run(self):
        return self.getIPs()

    def getReg(self, service: str):
        clint_service = self.sess.client(service)
        regs = clint_service.describe_regions()['Regions']
        return [r['RegionName'] for r in regs]

    def getIPs(self):

        def build_dict(ipAdds, reg, sec_grps, expoosed_ports, inst):
            return {
                        'name': self.get_tag_name(inst['Tags'] if 'Tags' in inst else []),
                        'ip_addresses': ipAdds,
                        'region': reg,
                        'security_groups': sec_grps,
                        'ports_exposed': expoosed_ports,
                        'status': '2' if len(expoosed_ports) else '1'
                    }

        # get all the regions
        regions, res, glb_stat = self.getReg('ec2'), [], "1"
        # for each region get the associated ec2 and see if they are public
        for reg in regions:
            inst_ec2 = self.sess.client('ec2', region_name=reg)
            resvns = inst_ec2.describe_instances()
            reserve_res = resvns['Reservations']
            for r in reserve_res:
                res_inst = r['Instances']
                for inst in res_inst:
                    ipAdds = [p_tmp_ipa['Association']['PublicIp'] for nw_inf in inst['NetworkInterfaces'] for p_tmp_ipa in nw_inf['PrivateIpAddresses'] if 'Association' in p_tmp_ipa]
                    l = len(ipAdds)
                    if l > 0:
                        # check all ports and see if there are any exposed ones
                        inst_sec_grp = inst['SecurityGroups']
                        sec_grps = self.get_sec_grps(inst_sec_grp)
                        expoosed_ports = self.bool_exposed_port(inst_ec2, sec_grps)
                        cond1, cond2 = len(expoosed_ports) > 0, glb_stat == '1'
                        if(cond1 and cond2):
                            glb_stat = '2'
                        d = build_dict(ipAdds, reg, sec_grps, expoosed_ports, inst)
                        res.append(d)
        return res, glb_stat

    def bool_exposed_port(self, ec2, security_groups):
        res = []
        sec_grps_inf = ec2.describe_security_groups(GroupIds=security_groups)
        for s_g in sec_grps_inf['SecurityGroups']:
            for perm in s_g['IpPermissions']:
                if self.check_my_port(perm):
                    cond1 = 'FromPort' in perm
                    cond2 = 'ToPort' in perm
                    if cond1 and cond2:
                        prot = perm['IpProtocol']
                        if prot == "-1":
                            prot = "all"
                        str_from_port, str_to_port = str(perm["FromPort"]), str(perm["ToPort"])
                        pref = "{0}/{1}"
                        my_port = pref.format(prot, str_from_port)
                        if perm['FromPort'] != perm['ToPort']:
                            my_port = pref+"-{2}".format(prot, str_from_port, str_to_port)
                        res.append(my_port)
        return res

    def check_my_port(self, perm):
        perm_ip_rng = perm['IpRanges']
        for r in perm_ip_rng:
            cidr = r['CidrIp']
            if cidr == '0.0.0.0/0':
                return True
        return False

    def get_sec_grps(self, security_groups):
        return [s['GroupId'] for s in security_groups]

    def get_tag_name(self, tags):
        s, n, v = 'Key', 'Name', 'Value'
        for tg in tags:
            if tg[s] == n:
                return tg[v]
        return 'NA'


class cls_Cloud_Jack(Base_Solution_Class):
    def __init__(self, sess):
        self.sess = sess

    def run(self):
        def get_row(hst_zn_id, hst_zn_type, given_name, dns_given__name, tmp_flag, cname=None, domain_name=None, distid=None, status = None):
            r = {
                            'hz_id': hst_zn_id,
                            'hz_type': hst_zn_type,
                            'name': given_name,
                            'cname': 'None',
                            'domain_name': 'None',
                            'dns_name': dns_given__name,
                            'distid': 'None',
                            's3': 'True',
                            'status': '2' if tmp_flag == 0 else '1',
                }
            return r
        st_poss = ['1','2']
        clnt_lst = ['route53', 'cloudfront', 's3']
        route53_client, cloudfront_client, s3_client = self.sess.client(clnt_lst[0]), self.sess.client(clnt_lst[1]), self.sess.client(clnt_lst[2])
        res, glb_stat, lst_hst_zns = [], "1", route53_client.list_hosted_zones()['HostedZones']
        # get all hostedzones from route53
        for hst_zn in lst_hst_zns:
            hst_zn_id, hst_zn_type = hst_zn['Id'].split("/")[2], 'Private Zone' if hst_zn['Config']['PrivateZone'] else 'Public Zone'
            hst_zn_recs = route53_client.list_resource_record_sets(HostedZoneId=hst_zn_id)['ResourceRecordSets']

            # get all records for the hostedzone
            for rec in hst_zn_recs:
                r_flg, name = 0, rec['Name'][:-1]

                # check if the record has an AliasTarget whose DNSName includes cloudfront or s3
                cond1 = 'AliasTarget' in rec
                cond2 = 'DNSName' in rec['AliasTarget']
                if  cond1 and cond2:
                    r1 = rec['AliasTarget']
                    r2 = r1['DNSName']
                    dom_nserv_name = r2[:-1]

                    if dom_nserv_name.find('s3') != -1:
                        sflag = 0
                        # check if there is bucket with the same name domain name
                        for buck in s3_client.list_buckets()['Buckets']:
                            if buck["Name"] == hst_zn["Name"][:-1]:
                                sflag += 1
                        if sflag == 0:
                            glb_stat = '2'
                        r = get_row(hst_zn_id, hst_zn_type, name, dom_nserv_name, sflag, cname=None, domain_name=None, distid=None, status = None)
                        res.append(r)

                    if dom_nserv_name.find('cloudfront') != -1:
                        c_flg = 0
                        # get all items from the cloudfront
                        cf_lst = cloudfront_client.list_distributions()['DistributionList']['Items']
                        for distrb in cf_lst:
                            distr_id, dom_name = distrb['Id'], distrb['DomainName']
                            # check if the domainname of the distribution contains the DNSName of the record
                            if dom_name.find(dom_nserv_name) != -1:
                                r_flg += 1
                                if distrb['Aliases']['Quantity']:
                                    for cname in distrb['Aliases']['Items']:
                                        if cname.find(name) != -1:
                                            c_flg += 1
                                            break

                        if r_flg and c_flg:
                            status = st_poss[0]
                        elif r_flg and not c_flg:
                            status = st_poss[1]
                            cname = None
                            glb_stat = st_poss[1]
                        elif not r_flg:
                            status = st_poss[1]
                            cname = domain_name = None
                            glb_stat = st_poss[1]
                        row = get_row(hst_zn_id, hst_zn_type, name, dom_nserv_name, sflag, cname=cname, domain_name=domain_name, distid=distr_id, status = status)
                        res.append(row)

        return res, glb_stat


try:
    lst = [config['ACCESS_KEY'], config['SECRET_KEY'], config['REGION']]
    sess = boto3.Session(aws_access_key_id=lst[0], aws_secret_access_key=lst[1], region_name=lst[2])
    cj, ep = cls_Cloud_Jack(sess), EC2_Ports_Exposed(sess)
except Exception as e:
    sess = None
    print('Erorr in Connecting with AWS!')


@app.route("/api/v1/checkall", methods=["GET"])
def check_all_api():
    if sess == None:
        res = {"results": []}
        return jsonify(res), 500
    ep_res, ep_st = ep.run()
    cj_res, cj_st = cj.run()
    data_dict_ep =  {"data": ep_res, "status": ep_res}
    data_dict_cj =  {"data": cj_res, "status": cj_st}
    return jsonify({"ep": data_dict_ep, "cj": data_dict_cj}), 200


@app.route("/api/v1/exposedports", methods=["GET"])
def exposed_ports_api():
    if sess == None:
        res = {"results": []}
        return jsonify(res), 500
    res, glb_stat = ep.run()
    data_dict = {"status": glb_stat, "data": res}
    return jsonify(data_dict), 200


@app.route("/api/v1/cloudjack", methods=["GET"])
def cloud_jack_api():
    if sess == None:
        res = {"results": []}
        return jsonify(res), 500
    res, glb_stat = cj.run()
    data_dict = {"status": glb_stat, "data": res}
    return jsonify(data_dict), 200


if __name__ == '__main__':
    app.run()
